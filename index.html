<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Tiny Rule Engine : A Tiny rule engine in C#  small, fast and extensible">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Tiny Rule Engine</title>
      <style type="text/css">
          .auto-style1 {
              font-size: large;
          }
      </style>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/BadLambdaJamma/TinyRuleEngine">View on GitHub</a>

          <h1 id="project_title">Tiny Rule Engine</h1>
          <h2 id="project_tagline">A tiny rule engine and SDK in C#: composable, small, fast and extensible.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/BadLambdaJamma/TinyRuleEngine/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/BadLambdaJamma/TinyRuleEngine/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">
            <strong><span class="auto-style1">September 2014 Version 1.0</span></strong>:
            Latest
            TinyRuleEngine - The simple math engine has been added!
            <hr />

            <p>
            With the simple math engine 
                example, almost any mathmatical equation can be dynamically built, converted to an abstract syntax tree, compiled, and evaluated, all at native code speed!</p>
            <p>
                &nbsp;</p>
            <p>
                <strong>A lightweight rule expressed in XML:</strong><br />
            </p>
            <strong>Simple math engine expression string for the resonant freuqncy of a "Tank" circuit:<br />
            <img src="images/resonantfrequncy.png" />
            <br />
            &lt;mathexp name=&quot;ResonantFrequencyOfATankCircuit&quot; appliesto=&quot;TinyRuleEngineTest.CircuitDTO&quot;&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;round&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;divide&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value item=&quot;@@1&quot; /&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value item=&quot;@@2&quot; /&gt;
            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value item=&quot;@Pi&quot;/&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;sqrt&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value item=&quot;InductanceInHenries&quot; /&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value item=&quot;CapacitanceInFarads&quot; /&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/sqrt&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/multiply&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/divide&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;/round&gt;<br />
            &lt;/mathexp&gt;</strong><br />
            <br />
            <br />
            <strong><span class="auto-style1">Fall 2013 .9 Beta Release: </span></strong>This is a minimal feature rule engine based on conposability and compact size.<br />
&nbsp;A simple C# rules engine for .NET using Linq Expressions, Lambdas, and Delegates.  small and fast.

            <br />
            1.  Supports a Code first model, or an all Code approach, to building, compiling and executing rules as discrete steps
            <br />
            2.  Supports XML Driven rules with deep logical nesting
            <br />
            3.  Supports Mix of Code and XML rules with logical operators and fluent syntax


            <br />
            <br />
            Supported Engines:<br />
&nbsp;&nbsp;&nbsp;

            1. RuleEngine - A Simple rule engine that evaluates rules against a given type (DTO type)
            <br />
&nbsp;&nbsp;&nbsp; 2. IdentityRuleEngine - Included support for making IClaimsPrincipal claim checks mixed with DTO rules.
            <br />
&nbsp;&nbsp;&nbsp; 3. TuppleRuleEngine - Supports Rules compiled against two DTO types (e.g. Car and SalesPerson )
            <br />
&nbsp;&nbsp;&nbsp; 4. IdentityTuppleRuleEngine - Support two DTO types (.e.g. car and Saleperson) +  IClaimsPrincipal<br />
            <br />
&nbsp;====================================================================================================
            Licensed as Open Source software under the Apache License.
            Please contact me with bugs, improvements or bitcoins - jonathananewell@hotmail.com

            Rule reader uses Predicate Builder to allow you to Join rule expressions in Code.

            ===================================================================================================
            Each type of rule engine is illistrated with unit tests:

            1. RuleEngine - A rule engine that evaluates against a single type defined by the developer or rule writer
            2. IdentityRuleEngine - A rule engine that supports claims principal checks mixed in with a generic type
            3. TuppleRuleEngine - A rule engine that evaulates against two types defined by the developer or rule writer
            4. IdentityTuppleRuleEngine - A Rule Engine that evaluates against two types and supports claims pincipal claim checks

            Here are the main features:

            1. Pure code model supported:  define, compile and execute rules in code.
            2. XML based model: Load complex rule graphs with deep cyclomatic logic from simple Xml files.
            3. Hybrid model:  mix-in your code and XML rules anyway you want with any logical operators.
            4. Pluggable rule readers.  Define your own rule language or variation without impacting consuming code.
            5. Performant - Uses .NET expression trees to create fast executeable code on the fly.


            ====================================================================================================
            Supported join operators:
            ====================================================================================================
            and
            or
            xor

            ===================================================================================================
            Supported comparison Operators
            ===================================================================================================
            string properties:

            Equals
            Startswith
            EndsWith
            Contains

            Numeric properties:
            Equals
            Lessthan
            GreaterThan
            LessthanOrEqual
            GreaterthanOrEqual

            ======================================================================================================
            Simple rule: 1 rule shown
            ======================================================================================================
            <rules>
                <rule name="IsApprover" appliesto="UnitTestProject1.User">
                    <ruleitem membername="Age" operator="Equals" targetvalue="22" />
                    <rule>
            </rules>
            ======================================================================================================
            Complex rule: 2 rules shown
            ======================================================================================================
            <rules>
                <rule name="IsApprover" appliesto="UnitTestProject1.User">
                    <and>
                        <and>
                            <ruleitem membername="Age" operator="Equals" targetvalue="21" />
                            <ruleitem membername="Name" operator="StartsWith" targetvalue="on" />
                        </and>
                        <and>
                            <ruleitem membername="Age" operator="Equals" targetvalue="22" />
                            <ruleitem membername="Name" operator="StartsWith" targetvalue="Jon" />
                        </and>
                    </and>
                </rule>
                <rule name="IsApproverSuperUser" appliesto="UnitTestProject1.User">
                    <ruleitem membername="Age" operator="Equals" targetvalue="22" />
                </rule>
            </rules>
            ======================================================================================================
            Complex rule: 3 -Identity rules shown with a group SID claim (any claim including role may be used)
            member name is set to the special value of @user
            operator is the claimType
            TargetValue is the claim value.

            Claims on the Principal are processed with this lambda:

            Expression<func<IClaimsPrincipal,string, string, bool>> HasClaimTest
	= (p, ct, cv) => p.Identities.Any(s => s.Claims.Any(c => c.ClaimType == ct &&  c.ValueType == ClaimValueTypes.String && c.Value == cv));

	p = the claim principal
	ct = the claim type
	cv = the claim value

======================================================================================================
<rules>
  <rule name="IsApprover" appliesto="TinyRuleEngineTest.User">
    <or>
      <and>
        <ruleitem membername="@User" operator="http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid" targetvalue="S-1-5-21-2493390151-660934664-2262481224-513" />
        <ruleitem membername="Name" operator="StartsWith" targetvalue="Jon"/>
      </and>
      <and>
          <ruleitem membername="@User" operator="http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid" targetvalue="S-1-5-21-2493390151-660934664-2262481224-513" />
          <ruleitem membername="Name" operator="StartsWith" targetvalue="on"/>
      </and>
    </or>
  </rule>
</rules>

=======================================================================================================
FAQuestions
=======================================================================================================
1. How come rule builder does not just call compile for me?

    Rule builder assumes a few things when it comes to calling compile:

	a. The developer knows best when to call compile.  Compiled rules should usually be backed by
	   a lazy loaded cache to avoid calling compile.

	b. Compile will sometimes invoke reflection, sometimes not.  For any operator but 'Equals' on a string comparison,
	   reflection will be used to build the expression.  None of the numeric operators invoke reflection when compile
	   is called.  None of the claims based rules invoke reflection.

	c. mix-ins are only suppoorted against expressions not compiled rules.  you can use mix-ins all you want and then
	   you call compile on the newly composed rule.

2. Your unit test foo seems rather week.
	a. More unit test are coming.

3. Future Plans?
	a. Some more - More unit tests
	b. More checks against 'Built in' Types like IClaimsPrincipal.
	c. Support rule "mix-in" at the XML level instead of just code.
	D. support a rule paradym with multiple generic<T>



Raw rule engine base performance:
1. rule engine predicate test  - execute this test 10K times in 5.550 seconds.  the test consists of:
   a. defining a DTO
   b. defining 4 rules,
   c. call the rule engine to get the expressions from the defined rules.
   d. Using fluent syntax to join the expressions together
   e. Compiling the rule

     </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Tinyruleengine maintained by <a href="https://github.com/BadLambdaJamma">BadLambdaJamma</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
